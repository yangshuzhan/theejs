<!DOCTYPE html>
<html lang="cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width,initial-scale=1.0">
	<meta http-equiv="x-UA-Compatible" content="ie=edge">
	<title>Document</title>
	<link rel="stylesheet" href="css/main.css">
	<style>
	body {margin:0;}
	canvas {width: 100%; height: 100%;}
	</style>
</head>
<body>
	<script src="js/three.js"></script>
	<script src="js/OrbitControls.js"></script>
	<script src="js/GLTFLoader.js"></script>
	<script src="js/EXRLoader.js"></script>
	<script src="js/EquirectangularToCubeGenerator.js"></script>
	<script src="js/EffectComposer.js"></script>
	<script src="js/ShaderPass.js"></script>
	<script src="js/RenderPass.js"></script>
	<script src="js/CopyShader.js"></script>
	<script src="js/SSAOPass.js"></script>
	<script src="js/SSAOShader.js"></script>
	<script src="js/SepiaShader.js"></script>
	<script src="js/FilmPass.js"></script>
	<script src="js/SimplexNoise.js"></script>
	<script src="js/SMAAPass.js"></script>
	<script src="js/SMAAShader.js"></script>
	<script src="js/SSAARenderPass.js"></script>
	<script src="js/CopyShader.js"></script>
	<script src="js/SAOPass.js"></script>
	<script src="js/SAOShader.js"></script>
	<script src="js/DepthLimitedBlurShader.js"></script>
	<script src="js/UnpackDepthRGBAShader.js"></script>
	<script src="js/dat.gui.min.js"></script>
	<script src="js/UnrealBloomPass.js"></script>
	<script src="js/LuminosityHighPassShader.js"></script>
	
	<script type="xshader-vertex" id="vertexshader">
		void main()
		{
			vec4 modelViewPosition=modelViewMatrix*vec4(position,1.0);
			gl_Position=projectionMatrix*modelViewPosition;
			
		}
	</script>
	<script type="xshader-Fragment" id="fragmentshader">
	void main()
	{
		glFragColor=vec4(1,0,0,1);
	
	}
	</script>
	
	<script>
	var scene = new THREE.Scene();
	var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight,0.1, 1000);


	
	//视图设置
	var renderer = new THREE.WebGLRenderer({antialias:true});
	renderer.setSize(window.innerWidth,window.innerHeight);
	renderer.shadowMap.enabled = true;
	renderer.shadowMap.type = THREE.PCFSoftShadowMap;
	document.body.appendChild(renderer.domElement);
	window.addEventListener('resize',function()
	{
	var width =window.innerWidth;
	var height= window.innerHeight;
	renderer.setSize(width,height);
	camera.aspect=width/height;
	camera.updateProjectionMatrix();
	composer.setSize( width, height );
	})
	camera.position.z=200;
	controls=new THREE.OrbitControls(camera,renderer.domElement);
	
	
	var maxAnisotropy = renderer.capabilities.getMaxAnisotropy();
	
	
	//加载立方体环境贴图
	/*
	var r="img/";
	var urls=[r+"2.png",r+"2.png",r+"2.png",r+"2.png",r+"2.png",r+"2.png"];
	var textureCube=new THREE.CubeTextureLoader().load(urls);*/
	
	
	//加载equirec环境贴图
	var textureEquirec;
	var textureLoader = new THREE.TextureLoader();
	
	textureEquirec = textureLoader.load( "img/3.jpg" );
	
	textureEquirec.anisotropy = maxAnisotropy;
	
	textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
	textureEquirec.magFilter = THREE.LinearFilter;
	textureEquirec.minFilter = THREE.LinearFilter;
	textureEquirec.encoding = THREE.sRGBEncoding;
	
	//load model
	//为每一个物体应用环境贴图
	const loader=new THREE.GLTFLoader();
	const url = 'untitled.glb';
	var root;
	var cube=new THREE.Object3D();
 	loader.load(url, (gltf) => {
    root = gltf.scene;
    scene.add(root);
	console.log(root);
	
	//测试物体cube
	root.traverse((cube)=>{
		if(cube.isMesh){
			cube.material=new THREE.MeshPhysicalMaterial().copy(cube.material);
	 if(cube.map!=null) cube.map.anisotropy = maxAnisotropy;
	 if(cube.material.name=="body")
	 {
	 cube.material.clearCoat=1;
	 cube.material.clearCoatRoughness=0;
	 
	 };
	 if(cube.material.name=="glass")
	 {
	 cube.material.opacity=.1;
	 cube.material.transparent=true;
	 
	 };
	 if(cube.material.name=="d_glass")
	 {
	 cube.material.opacity=0.5;
	 cube.material.transparent=true;
	 
	 };
	 cube.material.envMap=textureEquirec;
	 cube.material.envMapIntensity=3;
	 
	 
	 cube.castShadow=true;
	 cube.receiveShadow=true;
	 //cube.material.opacity=.3;
      console.log(typeof cube);
	
	
	
		}
	});
	
	
	
	
	
	

	/*
	cube.material.metalness=1;
	cube.material.roughness=.5;
	
	cube.material.bumpMap=texture;
	cube.material.envMap=textureCube;
	cube.material.envMapIntensity=1;
    cube.needsUpdate=true;	*/
	//console.log(cube);
	});
	
	
	
	//create texture
	var material1 = new THREE.ShaderMaterial({
		vertexShader: document.getElementById('vertexshader').textContent,
		fragmentShader: document.getElementById('fragmentshader').textContent
	});

	
	//ambientlight
	var hemlight=new THREE.HemisphereLight( 0xffffbb, 0x080820, 1 );
	scene.add(hemlight);
	
	// light shadow
	
	var light = new THREE.SpotLight( 0xffffff, 10, 0, Math.PI / 2 );
	light.position.set( 1000, 1500, 1000 );
	light.target.position.set( 0, 0, 0 );
	light.castShadow = true;
	scene.add( light );
	
	light.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 30, 1, 1000, 5000) );
	light.shadow.bias = -0.001;

	light.shadow.mapSize.width = 512;
	light.shadow.mapSize.height = 512;

	

	//game logic
	var update = function()
	{
	
	};
	
	
	//composer
	var composer = new THREE.EffectComposer( renderer );

	//passes
	var renderPass=new THREE.RenderPass(scene,camera);
	composer.addPass(renderPass);
		
	
	//smaa

			var pass = new THREE.SMAAPass( window.innerWidth * renderer.getPixelRatio(), window.innerHeight * renderer.getPixelRatio() );
			composer.addPass( pass );
	//fxaa
			
	

	
	//sao
	var saoPass = new THREE.SAOPass( scene, camera, false, true );
	composer.addPass( saoPass );

	//
	const colorShader = {
    uniforms: {
      tDiffuse: { value: null },
      tNormal: { value: null },
      color:    { value: new THREE.Color(0x88CCFF) },
    },
    vertexShader: `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1);
      }
    `,
    fragmentShader: `
      uniform vec3 color;
      uniform sampler2D tDiffuse;
	  uniform sampler2D tNormal;
      varying vec2 vUv;
      void main() {
        vec4 previousPassColor = texture2D(tDiffuse, vUv);
		

		
       gl_FragColor = vec4(
            previousPassColor.rgb * color,
            previousPassColor.a);
      }
    `,
 	 };
	 const colorPass = new THREE.ShaderPass(colorShader);
  composer.addPass(colorPass);

	
	
	//bloom
	var bloomPass = new THREE.UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
	bloomPass.threshold = 0.1;
	bloomPass.strength = 1.0;
	bloomPass.radius = 0.1;
	composer.addPass( bloomPass );
	
	
	bloomPass.renderToScreen=true;	
	//gui
	const gui=new dat.GUI();
	{
	
	const folder=gui.addFolder('SAOPass');
	folder.add( saoPass.params, 'saoBias', 0, 1 ).name('saoBias');
	folder.add( saoPass.params, 'saoIntensity', 0, .1 ).name('saoIntensity');
	folder.add( saoPass.params, 'saoScale', 0, 50 ).name('saoScale');
	folder.add( saoPass.params, 'saoKernelRadius', 0, 200 ).name('saoKernelRadius');
	folder.add( saoPass.params, 'saoBlur', 0, 1 ).name('saoBlur');
	folder.add( saoPass.params, 'saoBlurRadius', 0, 10 ).name('saoBlurRadius');
	folder.open();
	const folder2=gui.addFolder('shadow');
	folder2.add( light.shadow, 'bias', -0.01, 0.01 ).name('bias');
	folder2.add( light.position, 'x', -3000, 3000 ).name('position.x');
	folder2.add( light.position, 'y', -3000, 3000 ).name('position.y');
	folder2.add( light.position, 'z', -3000, 3000 ).name('position.z');
	folder2.open();
	const folder3=gui.addFolder('bloom');
	folder3.add(bloomPass,'strength',0,2).name('strength');
	folder3.add(bloomPass,'radius',0,1).name('radius');
	folder3.add(bloomPass,'threshold',0.0,1.0).name('threshold');
	folder3.open();
	const folder4=gui.addFolder('color');
	folder4.add(colorPass.uniforms.color.value, 'r', 0, 4).name('red');
	folder4.add(colorPass.uniforms.color.value, 'g', 0, 4).name('green');
	folder4.add(colorPass.uniforms.color.value, 'b', 0, 4).name('blue');
	folder4.open();
	}
	
	
	
	
	
	//draw scene
	var render = function()
	{
	composer.render();
	//renderer.render(scene,camera);
	};
	
	var GameLoop = function()
	{

	requestAnimationFrame(GameLoop);
	update();
	render();
	};
	
	GameLoop();
	
	
	</script>
</body>
</html>